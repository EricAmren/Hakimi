from itertools import combinations

class Atom:
    def __init__(self):
        self.valence = None
        self.freeBonds = None

    def __gt__(self, other):
        return self.freeBonds > other.freeBonds

    def __repr__(self):
        return str(self.valence)

def generate_first_minimum_graph(degree_sequence):
    # First, we need to create all needed vertices (n = number of atom)
    n = len(degree_sequence)
    minimum_graph = Graph(0, multiedges=False, loops=False)
    for degree in degree_sequence:
        atom = Atom()
        atom.valence = degree
        atom.freeBonds = degree
        minimum_graph.add_vertex(atom)
    # Then we need to add (n-1) edges to make the graph connexe.
    free_atoms = set(minimum_graph.get_vertices().keys())
    max_atom = max(free_atoms)
    free_atoms.remove(max_atom)
    connected_atoms = {max_atom}
    # for i in range(n-1):
    while free_atoms:
        max_connected = max(connected_atoms)
        max_free = max(free_atoms)
        minimum_graph.add_edge(max_connected, max_free)
        max_connected.freeBonds -= 1
        max_free.freeBonds -= 1
        free_atoms.remove(max_free)
        connected_atoms.add(max_free)
    return minimum_graph

def straight_switch(graph, edge0, edge1):
    v0, v1, label0 = edge0
    v2, v3, label1 = edge1
    graph.delete_edges([edge0, edge1])
    graph.add_edges([(v0,v2,None), (v1,v3,None)])

def reverse_straight_switch(graph, edge0, edge1):
    v0, v1, label0 = edge0
    v2, v3, label1 = edge1
    graph.add_edges([edge0, edge1])
    graph.delete_edges([(v0,v2,None), (v1,v3,None)])


def crossed_switch(graph, edge0, edge1):
    v0, v1, label0 = edge0
    v2, v3, label1 = edge1
    graph.delete_edges([edge0, edge1])
    graph.add_edges([(v0,v3,None), (v1,v2,None)])

def reverse_crossed_switch(graph, edge0, edge1):
    v0, v1, label0 = edge0
    v2, v3, label1 = edge1
    graph.add_edges([edge0, edge1])
    graph.delete_edges([(v0,v3,None), (v1,v2,None)])

### DONE

def generate_other_minimum_graphs(minimum_graph):
    # From our first minimum graph, we now need to generate all the others by
    # using the switch operation. It preserves the degree sequence.
    # In that instance, we need to iterate over all combinations of pair of
    # edges.
    # Switching edges both containing hydrogenes happens to be useless in our
    # case, so we'll pass these operations. (Graphs generated by switching
    # hydrogenes are isomorphs).
    # Moreover, there is no need to switch edges sharing one vertex.
    all_pairs = combinations(minimum_graph.edges(), 2)
    for pair in all_pairs:
        edge0 = pair[0]
        edge1 = pair[1]
        atom0 = edge0[0]
        atom1 = edge0[1]
        atom2 = edge1[0]
        atom3 = edge1[1]
        if edge0 == edge1:
            pass
        elif (atom0.valence == 1 or atom1.valence == 1) and (atom2.valence == 1 or atom3.valence == 1):
            pass
        elif atom0 in edge1 or atom1 in edge1:
            pass
        else:
            straight_switch(minimum_graph, edge0, edge1)
            yield(copy(minimum_graph))
            reverse_straight_switch(minimum_graph, edge0, edge1)

            crossed_switch(minimum_graph, edge0, edge1)
            yield(copy(minimum_graph))
            reverse_crossed_switch(minimum_graph, edge0, edge1)
    # return generator_of_minimum_graphs

ds = [4,4,4,3,3,2,2,1,1]
min_g = generate_first_minimum_graph(ds)
gen = generate_other_minimum_graphs(min_g)





### TODO
"""
def filter_invalid_minimum_graphs(generator_of_minimum_graphs):
    return generator_of_valid_minimum_graph

def get_incomplete_atoms(minimum_graph):
    return list_of_incomplete_atoms

def generate_complete_graphs(minimum_graph):
    list_of_incomplete_atoms = get_incomplete_atoms(minimum_graph)
    return generator_of_complete_graphs
"""


